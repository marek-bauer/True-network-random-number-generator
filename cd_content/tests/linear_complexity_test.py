import copy
import numpy
import scipy.stats as stats
from .utils import RANGES, T, get_range


# An implementation of the Berlekamp Massey Algorithm base on Wikipedia
def berlekamp_massey(block_data):
    """Gets length of the shortest LFSR which generates block_data"""
    n = len(block_data)
    c = numpy.zeros(n)
    b = numpy.zeros(n)
    c[0], b[0] = 1, 1
    l, m, i = 0, -1, 0
    int_data = [int(el) for el in block_data]
    for i in range(n):
        v = int_data[(i - l):i]
        v = v[::-1]
        cc = c[1:l + 1]
        d = (int_data[i] + numpy.dot(v, cc)) % 2
        if d == 1:
            temp = copy.copy(c)
            p = numpy.zeros(n)
            for j in range(l):
                if b[j] == 1:
                    p[j + i - m] = 1
            c = (c + p) % 2
            if l <= 0.5 * i:
                l = i + 1 - l
                m = i
                b = temp
    return l


def number_of_vectors(length, complexity):
    """Gets number of vectors length-bits which are generated by the shortest LFSR of length complexity"""
    if 2 * length - 2 * complexity > 2 * complexity - 1:
        return int(2 ** (2 * complexity - 1))
    else:
        return int(2 ** (2 * length - 2 * complexity))


def get_probabilities():
    """Gets theoretical probabilities of geting vector with specified shortest LFSR"""
    res = [sum(map(lambda x: number_of_vectors(1024, x), range(RANGES[0] + 1)))]
    for i in range(len(RANGES) - 1):
        t = sum(map(lambda x: number_of_vectors(1024, x), range(RANGES[i] + 1, RANGES[i + 1] + 1)))
        res.append(t)
    t = sum(map(lambda x: number_of_vectors(1024, x), range(RANGES[T - 2] + 1, 1025)))
    res.append(t)
    return list(map(lambda x: x / 2 ** 1024, res))


def linear_complexity_test(vector):
    """Tests randomness using complexity of LFSR generating it"""
    p = get_probabilities()
    O = [0] * T
    N = len(vector) // 1024
    for i in range(0, N):
        complexity = berlekamp_massey(vector[1024 * i:1024 * (i + 1)])
        O[get_range(complexity)] += 1
    chi_sq = 0
    for i in range(T):
        if p[i] != 0.0:
            E_i = N * p[i]
            chi_sq += (O[i] - E_i) ** 2 / E_i
    return 1 - stats.chi2.cdf(chi_sq, T - 1)
